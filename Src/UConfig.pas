{
 * UConfig.pas
 *
 * Implements class that stores program's configuration information.
 *
 * $Rev$
 * $Date$
 *
 *
 * ***** BEGIN LICENSE BLOCK *****
 *
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific language governing rights and limitations under the License.
 *
 * The Original Code is UConfig.pas.
 *
 * The Initial Developer of the Original Code is Peter Johnson
 * (http://www.delphidabbler.com/).
 *
 * Portions created by the Initial Developer are Copyright (C) 2007-2009 Peter
 * Johnson. All Rights Reserved.
 *
 * Contributor(s):
 *   NONE
 *
 * ***** END LICENSE BLOCK *****
}


unit UConfig;


interface

uses
  SysUtils, Classes;

type

  {
  TInputSource:
    Enumerates different sources of input used by program.
  }
  TInputSource = (
    isStdIn,        // standard input
    isFiles,        // files from command line
    isClipboard     // clipboard
  );

  {
  TOutputSink:
    Enumerates different output sinks used by program
  }
  TOutputSink = (
    osStdOut,       // standard output
    osFile,         // file from output file switch
    osClipboard     // clipboard
  );

  // Enumerates ids of supported output encodings
  TOutputEncodingId = (
    oeUTF8,
    oeUTF16,
    oeWindows1252,
    oeISO88591
  );

  {
  TDocType:
    Enumerates various kinds of documents that can be generated by program.
  }
  TDocType = (
    dtXHTML,        // complete XHTML document
    dtXHTMLHideCSS, // complete XHTML document with CSS hidden in comments
    dtXHTMLFragment // a fragment of HTML code, with no embedded style sheet
  );

  {
  TConfig:
    Class that records details of program's configuration. Used to determine
    how program behaves.
  }
  TConfig = class(TObject)
  private
    fQuiet: Boolean;              // Value of Quiet property
    fDocType: TDocType;           // Value of DocType property
    fInputSource: TInputSource;   // Value of InputSource property
    fOutputSink: TOutputSink;     // Value of OutputSink property
    fShowHelp: Boolean;           // Values of ShowHelp property
    fOutputFile: string;
    fOutputEncodingId: TOutputEncodingId;
    fInFiles: TStringList;
    function GetInputFiles: TArray<string>;
  public
    constructor Create;
      {Class constructor. Initialises object's default property values.
      }
    destructor Destroy; override;
    property InputSource: TInputSource
      read fInputSource write fInputSource default isStdIn;
      {Describes source to be used for program's input}
    property OutputSink: TOutputSink
      read fOutputSink write fOutputSink default osStdOut;
      {Describes destination of program's output}
    property DocType: TDocType
      read fDocType write fDocType default dtXHTML;
      {Type of document to be generated}
    property Quiet: Boolean
      read fQuiet write fQuiet default False;
      {Whether program is to display project progress on console. Setting Quiet
      to true inhibits visual output}
    property ShowHelp: Boolean
      read fShowHelp write fShowHelp default False;
      {Whether program is to display help}
    property OutputFile: string
      read fOutputFile write fOutputFile;
    property OutputEncodingId: TOutputEncodingId
      read fOutputEncodingId write fOutputEncodingId default oeUTF8;
    property InputFiles: TArray<string> read GetInputFiles;
    procedure AddInputFile(const FN: string);
    function OutputEncoding: TEncoding;
    function OutputEncodingName: string;
  end;


implementation


{ TConfig }

procedure TConfig.AddInputFile(const FN: string);
begin
  fInFiles.Add(FN);
end;

constructor TConfig.Create;
  {Class constructor. Initialises object's default property values.
  }
begin
  inherited;
  fInFiles := TStringList.Create;
  fInputSource := isStdIn;
  fOutputSink := osStdOut;
  fDocType := dtXHTML;
  fQuiet := False;
  fShowHelp := False;
  fOutputEncodingId := oeUTF8;
end;

destructor TConfig.Destroy;
begin
  fInFiles.Free;
  inherited;
end;

function TConfig.GetInputFiles: TArray<string>;
var
  Idx: Integer;
begin
  SetLength(Result, fInFiles.Count);
  for Idx := 0 to Pred(fInFiles.Count) do
    Result[Idx] := fInFiles[Idx];
end;

function TConfig.OutputEncoding: TEncoding;
begin
  Result := nil;
  if not (fOutputSink in [osStdOut, osFile]) then
    Exit;
  case fOutputEncodingId of
    oeUTF8: Result := TEncoding.UTF8;
    oeUTF16: Result := TEncoding.Unicode;
    oeWindows1252: Result := TMBCSEncoding.Create(1252);
    oeISO88591: Result := TMBCSEncoding.Create(28591);
  end;
  Assert(Assigned(Result), 'TConfig.OutputEncoding: Encoding not created');
end;

function TConfig.OutputEncodingName: string;
const
  Map: array[TOutputEncodingId] of string = (
    'UTF-8', 'UTF-16', 'Windows-1252', 'ISO-8859-1'
  );
begin
  if not (fOutputSink in [osStdOut, osFile]) then
    Exit('');
  Result := Map[fOutputEncodingId];
end;

end.

